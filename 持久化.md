#iOS持久化
* 文件系统
* 序列化和归档
* 数据库

---

##1.文件系统
不管是Mac OS X 还是iOS的文件系统都是建立在UNIX文件系统基础之上的。

###1.1 沙盒模型   
在iOS中，一个app的读写权限只局限于自己的沙盒目录中.

>**沙盒模型到底有哪些好处呢?**  
>安全：别的app无法修改你的程序或数据  
>保护隐私：别的app无法读取你的程序和数据  
>方便删除：因为一个app所有产生的内容都在自己的沙盒中，所以删除app只需要将沙盒删除就可以彻底删除程序了
 
 iOS app沙盒中的目录们
 
| 目录名称 | 说明 |
| --------- | --------- |
| app bundle | 如xxx.app 其实是一个目录，里面有app本身的二进制数据以及资源文件 |
| Documents | 存放程序产生的文档数据 |
| Library | 下面默认包含下面两个目录 Caches Preferences |
| tmp | 临时文件目录 |

如果我们想在程序中获取上面某个目录的路径，应该如何实现呢？
下面就讲讲路径的获取.
通过`NSPathUtilities.h `中的`NSSearchPathForDirectoriesInDomains`函数，我们便可以获取我们想要的路径.
此函数具体声明如下:

>NSArray *NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde);   
>**directory** 目录类型 比如Documents目录 就是NSDocumentDirectory   
>**domainMask** 在iOS的程序中这个取NSUserDomainMask   
>**expandTilde** YES，表示将~展开成完整路径

注意函数返回的类型为数组，在iOS中一般这个数组中只包含一个元素，所以直接取lastObject即可.


###1.2 NSFileManager
NSFileManager提供一个类方法获得一个单例.

	/* Returns the default singleton instance.*/
	+ (NSFileManager *)defaultManager;

下面罗列了NSFileManager的常用方法

* 新建目录  
	
		- (BOOL)createDirectoryAtPath:(NSString *)path withIntermediateDirectories:(BOOL)createIntermediates attributes:(NSDictionary *)attributes error:(NSError **)error;
createIntermediates这个参数一般为YES，表示如果目录路径中间的某个目录不存在则创建之,如果是NO的话，则要保证所创建目录的父目录都必须已经存在

* 获取目录下的所有文件

		- (NSArray *)contentsOfDirectoryAtPath:(NSString *)path error:(NSError **)error;
如果目录为空，则返回空数组

* 其他的一些方法

		- (BOOL)copyItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error;
		- (BOOL)moveItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error;
		- (BOOL)linkItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error;
		- (BOOL)removeItemAtPath:(NSString *)path error:(NSError **)error;

更多的可以查看文档 [NSFileManager Class Reference](http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSFileManager_Class/Reference/Reference.html).

在实际项目中，我们一般会写一个工具类来负责项目中所有的路径操作.

##2. 序列化（Serializations） 和 归档（Archives）
我们经常听到“序列化”，“反序列化”这样的字眼，其实“序列化”的意思就是将对象转换成字节流以便保存或传输，“反序列化”便是一个相反的过程，从字节流转到对象。

不过在Objective-C中这个对象和字节流的互转分成两类:

* **序列化** 数据类型（NSDictionary, NSArray, NSString, NSDate, NSNumber，NSData）对象和字节流之间(通常将其保存为plist文件)的转换
* **归档** 普通自定义对象和字节流之间的转换

不过本质上讲上述两种都是对象图(Object Graph)和字节流之间的转换.
Apple关于序列化和归档的编程指南: [Archives and Serializations Programming Guide](http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Archiving/Archiving.html) .

###2.1 序列化
在实际的项目中，我们一般是将NSDictionary或NSArray的对象保存到文件或者从文件读取成对象。
当然这种只是适用于数据量不是很大的应用场景。
NSDictionary和NSArray 都有一个写入文件的方法
		
		- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;

NSDictionary和NSArray会直接写成plist文件

####2.1.1 序列化的方式
其实序列化的方式分两种

#####使用数据对象自带的方法
写文件

 	   NSMutableDictionary *dataDictionary = [[[NSMutableDictionary alloc] init] autorelease];
	    [dataDictionary setValue:[NSNumber numberWithInt:222] forKey:@"intNumber"];
	    [dataDictionary setValue:[NSArray arrayWithObjects:@"1",@"2", nil] forKey:@"testArray"];
	    [dataDictionary writeToFile:@"/Users/Luke/Desktop/test.plist" atomically:YES];
   
写完的文件内容如下:

	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
	<plist version="1.0">
	<dict>
		<key>intNumber</key>
		<integer>222</integer>
		<key>testArray</key>
		<array>
			<string>1</string>
			<string>2</string>
		</array>
	</dict>
	</plist>
   
   从文件读取
   
	NSDictionary *dictionaryFromFile = [NSDictionary dictionaryWithContentsOfFile:@"/Users/Luke/Desktop/test.plist"];

##### 使用NSPropertyListSerialization类
通过NSPropertyListSerialization类可以将数据对象直接转成NSData或者直接写到文件或者流中去.

	NSMutableDictionary *dataDictionary = [[[NSMutableDictionary alloc] init] autorelease];
	[dataDictionary setValue:[NSNumber numberWithInt:222] forKey:@"intNumber"];
	[dataDictionary setValue:[NSArray arrayWithObjects:@"1",@"2", nil] forKey:@"testArray"];

	NSString *error;
	NSData *xmlData = [NSPropertyListSerialization dataFromPropertyList:dataDictionary
                                                             format:NSPropertyListXMLFormat_v1_0
                                                   errorDescription:&error];
	if(xmlData) {
	    NSLog(@"No error creating XML data.");
	    [xmlData writeToFile:@"/Users/Luke/Desktop/test2.plist" atomically:YES];
	}
	else {
	    if (error) {
	        NSLog(@"error:%@", error);
	        [error release];
	    }
	}

读取

	NSDictionary *dictionaryFromFile = (NSDictionary *)[NSPropertyListSerialization 
 	                                                   propertyListWithData:[NSData dataWithContentsOfFile:@"/Users/Luke/Desktop/test2.plist"] 
	                                                    options:0
	                                                    format:NULL
	                                                    error:&error];
	                                                    

	                                                   
####2.1.2 User Defaults
每一个程序都会保存一些设置数据，比如记住上次窗口的位置和大小，记住是否弹出某些提示信息等。苹果提供了一个统一的解决方案，就是每一个app都有一个plist文件专门用以保存偏好设置数据。
plist文件名默认是程序Bundle identifier,扩展名为plist，保存位置为 `~/Library/Preferences`.
我们可以通过`NSUserDefaults`类来读写Preferences设置，而无需考虑文件位置等细节问题。

`NSUserDefaults`用起来和`NSDictionary`很相似。
`NSUserDefaults`一样提供了一个获取单例的方法.

	                                                   	                                                   	                                                   
###2.2 归档

##数据库
